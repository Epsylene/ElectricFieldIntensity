
#include "Field.h"

/**
 * Field constructor. 'E', the field, is set to 0.
 */
Field::Field()
{
    E = 0;
}

/**
 * Field generated by a particle at a given point.
 * @param x x component of the point's position
 * @param y y component of the point's position
 * @param particle Reference to the particle
 * @param realistic Realism flag
 * @return Either the actual electric field formula if realism
 *  is on, or a modified version if it is off.
 */
float Field::particleFieldAt(int x, int y, Particle &particle, bool realistic)
{
    if(realistic)
        return 1/(4*3.14f) * particle.q/(pow(x - particle.x, 2) + pow(y - particle.y, 2));
    else
        return 1/(4*3.14) * particle.q/sqrt(sqrt(sqrt(((pow(x - particle.x, 2) + pow(y - particle.y, 2))))));

    //The "non-realistic" option exists for aesthetic purposes only
    // (try "Beauty" drawing method with realistic set to "true"!)
}

/**
 * Get the vector where all particles are stored.
 * @return Particles vector
 */
std::vector<Field::Particle> *Field::getParticles()
{
    return &particuli;
}

/**
 * Calculate the electric field at a given point.
 * @param x x component of the point's position
 * @param y y component of the point's position
 * @param realistic Realism flag
 * @return Field at x, y
 * @see particleFieldAt
 */
float Field::fieldAtPoint(int x, int y, bool realistic)
{
    E = 0;

    for (auto &particle: particuli)
    {
        E += particleFieldAt(x, y, particle, realistic);
    }

    return E;
}

/**
 * Calculates the highest and lowest field values.
 */
void Field::fieldRange()
{
    for (auto &localField: fields)
    {
        if(upper < localField)
            upper = localField;
        if(lower > localField)
            lower = localField;
    }
}

/**
 * Get the vector containing all field values for each point
 * (actually, the number of field values depend on the
 * drawField() function)
 * @return Fields vector
 */
std::vector<float> *Field::getFields()
{
    return &fields;
}
